# 2020/8/4(今日完成1.网页结构；2.HTML文本)
### 网页基础
+ 结构：html
+ 表现：css
+ 行为：javascript

### Web开发软件
+ Hbuilder
+ 快捷键
    - 整理代码格式：Ctrl+Shift+f
    - 穿越Ctrl+上键或者下键

### 标签基础
+ 标签的关系
    - 嵌套关系：包含，父子标签，如"《html》《head》《/html》《/head》"
    - 并列关系：兄弟标签《head》《/head》《body》《/body》
+ XHTML标签要求任何没有结束标签的标签都要在结尾包含一个斜杠

### 常用单标签
+ 《!DOCTYPE html》：样本代码，声明代码的版本
+ 《meta》通常用于优化页面被搜索的可能性，定义版权信息
    - 属性：charset（字符集，="UTF-8"）
    - 属性：name="属性"content="对属性具体描述的词汇"
        * name=keywords，向搜索引擎说明页面关键字，后面放关键字（英文，隔开）
        * name=description，向搜索引擎描述页面内容，后面放内容
        * name=generatop，描述生成的软件
        * name=author，描述设计者姓名
        * name=robot，向页面说明限制搜索的方式，后面可输入all、none、index、noindex、follow、nofollow
    - 属性：http-equiv="refresh"content="2;url=http://www...",2秒后跳转至url所示网页
+ 《link》用于定义外部文件链接，常用于外部CSS样式——???待补充
+ 《base》——???待补充
+ 《style》用于定义CSS的样式——???待补充
+ 《script》用于定义页面内的脚本，如JS——???待补充
+ 《!--注释内容--》
    - 快捷键：Ctrl+/
+ 《hr/》水平线标签
    - 属性：align，编辑对齐模式
    - 属性：width，编辑水平线长度
    - 属性：size，编辑水平线宽度
+ 《br/》换行标签，0倍行距

### 常用双标签
+ 《html》开始标签，定义页面的开始与结束
+ 《head》头标签，有6个特殊标签可以放在头标签中使用（title、meta、link、base、style、script）
+ 《title》标题标签，设置网页的标题名（显示在选项卡）
+ 《body》主体标签，所有显示在网页中的内容均被其包含
+ 《h1》/.../《h6》标题标签
+ 《P》段落，单倍行距
    - 空格符号：&nbsp；
    - 注册商标符号：&reg；等等
    - 属性：align=left（左对齐）/center（居中）/right（右对齐）
+ 《pre》将其中文本格式化为等宽字体，保留文本中的空格符、分行，尽量少用
+ 《font》文本标签
    - 属性：color(="red")，字体颜色
+ 《b》或《strong》加粗，后者有些浏览器不一定准确显示
+ 《i》或《em》倾斜，后者有些浏览器不一定准确显示
+ 《u》或《ins》下划线，后者有些浏览器不一定准确显示
+ 《s》或《del》删除，后者有些浏览器不一定准确显示
+ 《sup》上标
+ 《sub》下标
+ 《acronym title="注释内容"》被注释内容《/acronym》
+ 《ul》无序列表
    - 《li》为每行无序列表增加句首符号
    - 无序列表可多级嵌套，无序和有序列表可混合嵌套
+ 《ol》有序列表
    - 《li》为每行有序列表增加序号
    - 属性：type="1/A/a/I（大写罗马）/i（小写罗马）"，设置序号格式
    - 有序列表可多级嵌套，无序和有序列表可混合嵌套
+ 自定义列表，被一组dl管理，dt是主题，dd是列表项

# 2020/8/5（今日完成1.HTML图片；2.HTML表格；3.HTML表单；4.CSS文本基本样式）
### 《img src="相对路径"/》图片标签
+ 属性：width="800"，宽度，单位是px
+ 属性：height="800"，高度，单位是px
+ 属性：title="提示信息"，提示信息，鼠标指向时显示
+ 属性：alt="替换文本"，图挂了时显示
+ 属性：border="5"，边框宽度，单位是px
+ 属性：src，如果图片在同一文件夹，相对路径=文件名
    - 如果图片在同文件夹的下级文件夹，先打开文件夹，如DOC/**.jpg
    - 如果图片在上级文件夹中，先返回上级，如../**.jpg
    - 如果图片路径是上级和下级混合，按照从左到右顺序依次描述路径
+ 属性：align="left/right/top/bottom/middle"，居左/居右/与文本上对齐/与文本下对齐/与文本中对齐
    - 居中命令center在《img/》标签内不起作用，只能添加在标签外，如《p》中
+ 属性：hspace="30"/vspace="30",将图片左右/上下与其他内容的间距设为30px

### 《body background="高频词.jpg"》，使用图片作为页面背景，自动平铺

### 《body bgcolor="#FF0000"》，使用红色作为背景

### 《a href=""》点击内容《/a》，跳转至链接
+ href后可添加相对路径（内部文件）或绝对路径（外部网址），点击内容可以是文字也可以是图片
+ 锚点链接，先用《a name="标记"》标记锚点（标记不要用数字开头），再用《a href="#标记"》跳转至锚点
+ 属性：target="_blank"，在新窗口中打开链接
+ href="#"，回到网页顶部，##为空链接

### 表格，被《table》管理，
+ 属性：border="1"，表格边框宽度1，默认为0px
+ 属性：cellspacing="0"，将边框间距设为0，默认为2px
+ 属性：width——表格宽度，height——表格高度
+ 《caption》为表格标题，《tr》为行，《td》为单元格，《th》为表头（默认加粗居中）
    - 属性：align="left/center/right"，单元格内位置

### 表单
+ 《form》,表单域
    - 属性：action="地址"，表单提交地址
    - 属性：method="get/post",表单提交方式——???待补充
+ 《label》,标题
    - 属性：for="txt1"，关联输入框的id属性,点击标题即可输入
+ 《input》,输入框
    - 属性：type="text"，输入为文本类型
    - 属性：id="txt1"
    - 属性：type="password",输入信息显示为**
    - 属性：type="radio"，可用于从多个选项中选择一个，如加name="相同的名称"，则使多个按钮形成单选的效果
    - 属性：checked=""在点选中，代表默认选中
    - 属性：type="checkbox"，复选框，yes or no
    - 属性：name="表单名字"，用于后台或JS识别
    - 属性：size="字段长度"，文本框的长度
    - 属性：maxlength="最长字符"，可输入的最长字符数量
    - 属性：value="预设信息"，预先设置好的信息
+ 《select》，下拉框 
    - 《option》，下拉框选项
        * 属性：selected=""，默认选中
    - 《optgroup label="组名"》，为下拉框的option分组
+ 《textarea》，文本域
+ 《button》按钮名称《/button》
    - 属性：type="submit"，提交按钮
    - 属性：type="reset"，重置按钮
    - 属性：type="button"，可点击按钮

### 可通过chrome浏览器页面右键的检查，进行调试

# 2020/8/6(今日完成1.三种CSS写法；2.显示模式转换；3.各种选择器使用及优先级；4.伪类标签使用；5.文本属性继承；6.各类基本样式)
### 内嵌式CSS（页联），《style type="text/CSS"》《style》,将CSS样式写在网页《head》中，和html代码相对分离，便于维护

### 标签选择器：《style》标签内，定义h1、p等标签，格式为h1{}，大括号内放置样式，每句以“；”结尾

### 块级显示模式：自己单独占一行，设置宽高起作用，默认宽度和父元素一样
+ 块元素包含：div、h1-h6、p、ul、li、ol、dl、dt、dd、hr、form

### 行内显示元素：设置宽高不起作用，自身大小靠文本撑开，一行可以有多个
+ 行内元素包括：span、b、strong、i、em、u、ins、s、del、a

### 行内块显示模式：设置宽高起作用，一行可以有多个
+ 行内块元素包括：img、表单元素

### 显示模式转换：可在标签选择器中用display：block/inline-block，切换块模式和行内块模式

### h1或p等文本标签
+ 样式：color：red/rgb（255,0,0）/#FF0000，三种表示方法（英文/十进制/十六进制）均表示红色
+ 样式：font-size：60px，将字体大小设置为60px，默认16px
+ 样式：font-family："宋体"，将字体设置为宋体，当字体为汉字或多个单词时，必须加双引号，默认微软雅黑
+ 样式：text-algin：center/left/right，文本居中/居左/居右，默认为居左
+ 样式：font-weight：400，字体粗细,400（normal）为正常粗细，700（bold）为加粗
+ 样式：text-indent：2em，首行缩进两个字体大小，也可用2px来缩进两个像素

### div，无语义元素（大盒子），可借助实体化三属性（宽、高、背景色）呈现
+ 样式：width：200px
+ 样式：height：200px
+ 样式：background：blue，将背景色设为蓝色

### 类选择器
+ 定义类名用“.”开头，标签中用class属性调用，不加点
+ 命名规范：定义类名时不能用数字开头，对大小写敏感
+ 建议用驼峰命名法，如greenBigStudent，第一个单词小写，之后每个单词首字母大写
+ class在调用类时可同时调用多个，中间用空格隔开

### id选择器
+ 用#加id名称定义，用标签中的id属性调用，不加#
+ 类选择器可以重复使用，id选择器不行——???待补充

### 行内式CSS（内联），将CSS作为标签的style属性书写，例如《div style="width:100px;height=100px"》
+ 将CSS样式写在网页的标签中，和html代码掺杂，难以维护

### 外链式CSS（外联），单独创建CSS文件，如《link rel="stylesheet" type="text/css" href="one.css"/》
+ 在html中用link进行关联，代码绝对分离，便于维护，工作中通常使用此方式进行开发

### CSS层叠性，对同一标签多次设计不同属性时，可以同时实现

### CSS对同一属性的CSS优先级：!important＞行内样式（内联）＞id选择器＞类选择器＞标签选择器，后定义＞先定义
+ 加了!important的优先级最高，如color：red !important；
+ 外链的CSS按照本身优先级及《link》标签所处的先后位置决定优先级

### 后代选择器,在选择器后再加选择器，只有多级选择器都满足，才使用样式，用空格隔开，如.lei1 .lei2{}或div h1{}

### 继承，父元素被选择器定义文本属性后，后代元素继承最近的父元素文本属性（包括居中、行高）
+ 前提：后代元素自身未被定义，否则使用自身文本属性
+ h和a标签继承的文本属性，会被标签自带的属性覆盖，如需改变需要单独定义

### 伪类，为a标签的文本定义的多种状态下的样式
+ a：link{}/a：visited{}/a：hover{}/a：active{}，对应默认/访问后/鼠标移入/鼠标按下四种状态
+ 四种状态顺序不能颠倒
+ 除了用标签选择器之外，还可以用类选择器加class引用，如.a：link{}

### 行高，line-height
+ 每行文本从上到下有四条线，分别是顶线、中线、基线（字母主体下沿，如q的封闭区域下沿）、底线
+ 行高即相邻两行基线之间的距离
+ 单行文本默认垂直居中于盒子（如span），行高等于盒子的高度
+ 要使单行文本在块元素中垂直居中，将行高设为块元素的高度即可
+ 当只设置了行高时，没设置高度时，高度默认为行高

# 2020/8/7(今日完成1.字体样式；2.强制英文换行；3.块元素边框、内外边距；4.块元素水平居中)
### 字体样式
+ 下划线样式：text-decoration：underline（下划线，同《u》，a标签默认），如是none则无下划线
+ 删除线样式：text-decoration：line-through，同《s》
+ 鼠标样式：cursor：pointer（鼠标显示为小手），链接a标签下默认为小手
+ 斜体样式：font-style：italic，normal为正常，同《i》
+ 粗体样式：font-weight：bold，同《b》
+ 综上，所有的行内样式标签都可以自己写，但为了代码可读性，需要标签语义化

### word-break：break-all，强制英文换行，如未添加的一连串英文字母，会被认为是一个单词而不换行

### 复合属性：如font-打头的样式，可以合并为font：40px “宋体”，空格隔开，至少写两个（大小、字体），如需写行高，写为40px/60px（后面是行高，也可写1.5，即1.5倍）
+ 当出现font复合属性时，会覆盖上方单独的font属性，因此要使单独属性生效需写在下方

### 块元素边框：border-width:5px;  border-color:black;  border-style:solid/dashed/dotted/double（实线/虚线/点状线/双实线）;
+ 同样可使用复合属性，粗细（默认3）、颜色（默认黑）和样式最好都写
+ 可使用left/right/top/bottom，单独画某一条边框
+ 可在复合属性下方加border-bottom：none，去掉下方边框
+ 边框会使得块元素尺寸变大

### 背景图：background-image：url（图片.jpg），默认平铺
 + background-repeat：no-repeat，取消平铺
 + background-repeat：repeat-x/y，横向/纵向平铺
 + 如在背景图上方已设置了背景色，重叠部分，背景图会覆盖背景色
 + background-position：left top，图片左上显示，如果图片大于盒子（div）范围，默认只显示左上角
 + 图片位置也可用0px 0px（左上），坐标的形式设置
 + 可使用center center，显示中间部分
 + background也可使用复合元素
 
### PS基本使用
+ 切片为保存web格式
+ 吸取颜色
+ Ctrl+左键可切换切片
+ del可删除切片

### 内边距padding，块元素加了内边距后，会与内容有间距，但此时的间距是通过块元素变大实现的（固定宽度的情况下）
+ 如padding-left：10px，左边内边距为10px
+ 块元素尺寸=自身尺寸+内边距+边框
+ 如果未给块元素设定宽度，则块元素宽度始终与父元素相同，内容尺寸将被压缩
+ 复合元素排序为上右下左，顺时针，只写2个即第一个为上下，第二个为左右

### 外边距margin，盒子（块元素）与盒子之间的距离
+ margin的属性写法可参考padding，但不会影响块元素尺寸
+ 相邻两个块元素外边距会合并，取值为较大的值
+ 外边距塌陷问题，嵌套的两个块元素，当给子元素（第一个）设置向上的外边距时，父元素也会掉下来
+ 解决外边距塌陷方案1：给父盒子设置overflow：hidden属性
+ 解决外边距塌陷方案2：改为给父盒子设置内边距

### 快捷键
+ 在body中输入div.box，按下Tab键，自动生成《div class="box"》《/div》
+ 在body中输入a*5，按下Tab键，自动生成5个《a href=""》《/a》
+ 在body中输入ul》li*5》a，按下Tab键，自动生成5行带a的列表

### 清除标签默认属性
+ *{margin：0；padding：0；}，*代表所有的标签，工作中不要这么用
+ 工作中用h1,p,li{margin：0；padding：0；}
+ h1-6,ul,li,ol,p等标签都有默认内外边距

### 并集选择器：h1,p{margin:0;padding:0;},用逗号相连，对多个标签同时定义样式 

### 块元素水平居中
+ margin:0px auto;
+ 行内和行内块元素水平居中：给父元素设置text-align：center

# 2020/8/8（今天开始仿淘宝首页，未完成）
### 常规三种显示模式（块、行内、行内块）叫做标准流

### 浮动：是一个属性float，是半脱离标准流，相当于漂浮至上一层，不参与标准流层从上至下的排列
+ 浮动元素间会根据从上往下的顺序，实现横向布局
+ float：left/right，靠左浮动/靠右浮动
+ 为了实现横向排列，行内元素和行内块元素会使得同行元素的上下位置随之变化，浮动则不会（优点）
+ 浮动不会对上方的标准流产生影响，但下方的标准流会上移，因此需要为浮动创造一个占位的标准流
+ 为浮动元素创造一个高度可随之变化的标准流，并包含浮动元素，需为标准流调用clearfix：after伪类，否则标准流无法随浮动变化占位
+ 行内元素加了浮动后，也可设置宽高
+ 当标准流内有文本时，即便文本位置被浮动元素覆盖，文字也会自动移开，环绕上方的浮动元素

### seo，search engine optimization，搜索引擎优化
+ 从seo角度，导航的a标签连续排列，会被se认为关键词堆砌作弊，所以可用列表隔开
+ ul/ol属性：list-style:none，取消列表样式(通常用于取消每行前面的标识符)
+ 在块元素中插入img（行内块元素），会造成图片下方留白，此时需将img转化为块显示模式

### chrome默认字号1em=16px

### font-size：100%：字号为父级的100%

### 页、外联CSS表格单元格间距：border-spacing：0px

### 页、外联CSS表格单元格边框重叠：border-collapse：collapse

### CSS中字体可以设置多个，浏览器按顺序识别，能识别就直接使用,用逗号隔开
+ 字体可以有3种表示方式，中文、英文、Unicode,当设置多个时，要用引号包裹

### 实际项目CSS模块
+ 为了消除浏览器之间的呈现差异，需要对CSS进行初始化，清除一些CSS样式
+ 为了让整个网站的各个网页形成一样的风格，需要对一些CSS进行统一的设置

### 网页的版心：页面固定显示宽度，即内容呈现范围的宽度，通常根据设备屏幕分辨率设计
+ 早期电脑分辨率较低，版心宽度通常是960px，以现在的淘宝网为例，版心是1190px
+ 版心水平居中于浏览器
+ 通栏的盒子（通常在上方）无固定宽度，根据浏览器宽度决定

# 2020/8/9（今天继续仿淘宝，顺便按进度把京东也仿了）
### h1在网页中只出现一次，用于logo

### overflow，溢出属性，为父元素设置当子元素内容溢出父元素范围时的设置
+ overflow:hidden，溢出部分隐藏
+ overflow:scroll，转化为滚轮窗口
+ overflow：auto，未溢出时正常，溢出时转化为滚轮窗口

### 根据选择器的权重累加可实现层叠优先级，通常3种，id/类/标签，权重分别设为100/10/1，计算（多次出现应多次相加）
+ 因此当需要控制优先级时，可控制后代选择器书写的具体程度（即是否把每一级选择器都写出）
+ 或者通过！important强行提权

### input元素属性：placeholder="提示信息"，生成提示信息（CSS3中的文本提示属性）

### border-radius:13px,将元素边框设置为圆角，数值为圆角半径

# 2020/8/10(今日完成1.相对定位；2.绝对定位；3.CSS sprite)
### 定位：改变元素位置
+ 相对定位：position：relative；基于自身在网页（父元素）中的位置进行调整,移动后不会影响其他元素，并且仍然在原先标准留位置占位
    - left、top、right、bottom，选择参考点，根据参考点：1px，向基线相反方向平移1px
+ 绝对定位：position：absolute；完全脱离标准流的状态，无法占位，可以将元素设置在网页中一个具体的坐标位置
    - left、top为将网页(父元素)的左上作为元素（子元素）的起始参考点,right、bottom将元素在网页（父元素）第一屏（根据窗口大小决定）的右下作为起始参考点
+ 当4个参考点都有时，以left和top为准
+ 当有多个父元素时，需在想放置的父元素中使用相对定位，确定默认参考点

### 层级（z-index），层级大的元素，显示时在上方，可通过z-index：1属性设置元素层级
+ 当元素设置定位后，层级默认为0，层级相同时，后写的标签会压在后写的上面

### 垂直水平居中：用一对定位的父子元素来做
+ 为父元素添加相对定位，确定默认参考点
+ 为子元素添加绝对定位，将坐标设为50%width，50%height，用margin回撤自身的50%width和50%height

### 透明度：opacity：0.5（取值为0~1），越小透明度越高，也可在rgba（0,0,0,0.5）处设置

### CSS精灵：也叫CSS sprite，是背景图的技术
+ 目前网速较快，但服务器的连接数是有限的
+ 一次性下载大的背景图，按需要显示其中的一小部分
+ 将父元素设置成需要的尺寸，用background-position：0px 0px；控制露出的部分

# 2020/8/11(今天完成1.图标字体；2.固定定位；3.跨行元素排布；4.画圆形；5。快进切图视频，确认掌握了静态淘宝需要的CSS技巧。今天开始JS)
### 圆形可以通过正方形元素的border-radius：50%边长实现，即通过圆角边框产生，内外还可呈现不同颜色

### 图标字体：一种字体，可以展现图形，加载速度更快，放大后更清晰
+ 下载网站：http://www.iconfont.cn/
+ 图标字体三种用法
    - 1.unicode引用（可兼容最老ie6，图标用代码引用，语义化差），在元素中直接输入
    - 2.fontclass引用（可兼容最老xp的ie8，语义化好，），在元素样式中输入
    - 3.symbol引用（可兼容最老ie9，语义化好，可彩色，渲染性能一般），在专用标签输入

### 固定定位：将元素固定到浏览器界面的某个坐标位置,position:fixed
+ 同样是用left、top、right、bottom设置位置
+ 不需要父元素有起始定位，因为坐标基于浏览器界面
+ 但需要为子元素设置宽度高度，如需跟随父元素宽度，则width：100%
+ 固定定位的元素压在其他元素上方

# 2020/8/12（今日完成：JS基础的一部分，基本语法和部分函数）
### javascript，JS简介
+ js如今能做交互（表单验证）、网页动态效果、服务器端开发（Node.js）、游戏等
+ js是一门脚本语言
    - 弱类型语言，变量数据类型较灵活
    - 解释型语言，不需经过编译成二进制，可直接在浏览器中运行
    - 动态语言，可以动态添加属性和方法
    - 基于对象语言，有类（class）的概念，但缺少很多面向对象语言的特征
    - 大小写敏感

### 学习js的三部分
+ 1.ECMAScript（欧洲计算协会）：语法
+ 2.DOM，document object model：文档对象模型
+ 3.BOM，browser object model：浏览器对象模型

### 三种js写法
+ 内嵌式（页联）js：body标签下《script type="text/javascript"》《/script》标签
    - 快捷键，《script》中Ctrl+Shift+/，多行注释
    - 默认由上往下
    - 每句代码用分号结束
    - 每句代码最好换行，好看
    - 页面加载后执行
+ 行内式（内联）js：例如button标签下《button onclick="alert('行内式')"》按钮《button》
    - 需要执行父标签的属性才执行
+ 外链式（外联）js：body标签下《script src="one.js" type="text/javascript" charset="utf-8"》这里别写内嵌式代码《/script》
+ 内嵌式和外链式执行的先后顺序取决于代码的先后顺序

### 计算机的执行过程：cpu将硬盘中的数据调度到内存中运行
+ cpu，中央处理器
+ 内存：暂时对数据的存储
+ 硬盘：永久性存储

### 变量：暂时对不同数据类型的数据进行存储
+ 定义变量：var 变量名称 =‘变量值’；
+ 也可拆为2句：var 变量名称；变量名称=‘变量值’
+ 命名规范：可以字母、数字、下划线、$，不能用数字开头，

### js不同数据类型
+ 数值类型(number)：1 5 3.14 -9
+ 字符串类型(string)：‘哈哈’ ‘13888’ ‘abc’
    - 纯数字字符串在进行减乘除运算时会先隐式转换为数值类型
    - 字符串和任何数据类型进行相加操作，都会产生拼接效果
    - 非纯数字字符串进行减乘除运算时，会显示NaN（not a number）
    - 让两个纯数字字符串用加号拼接方法：1.中间加一个空字符串；2.其中一个变量后加.tostring（）
+ 布尔类型(boolean)：true和false
    - 隐式转换后对应1和0
+ 未定义类型(undefined)：当变量只声明，但未赋值时，就是undefined
+ 对象类型（object）：复杂的数据类型——？？？待补充
+ 空类型（object）：只有一个值null 

### 数据类型转换
+ 其他类型转换成数值类型
    - 函数parseInt():转换成数值，并向下取整（从左开始遇到字母或其他字符则转换终止，布尔不能转，null不能转）
    - 函数parseFloat（）：转换成可带小数的数值（特性同上括号内）
    - 函数Number（）：转换成数值（严格型转换，只能转换纯数字，布尔可以转，null转0）
+ 其他类型转换成字符串类型
    - 函数.toString（）：数字和布尔都可以转（布尔会转成true或false）
    - 函数String（）：undefined和null可以转
+ 其他类型转换成布尔类型
    - 函数Boolean():将不为0的数据或0转换成true或false（undefined、空字符、null也为false）

### 函数alert（），在浏览器弹出对话框，括号中放显示内容，没有返回值
+ 字符串最好用单引号，复制带双引号的字符串不容易出错？

### 函数console.log（）:在浏览器控制台输出

### typeof 数据：获取数据类型
+ 当数据位置放置的是变量时，获取的时变量值的数据类型

### 字符串.length：获取字符串字符的个数

### 前++和后++
+ ++a和a++都是+1再赋值给a自身
+ a=1；c=++a；计算结果a=2，c=2（前++是先加1再计算）
+ a=1；c=a++；计算结果a=2，c=1（后++是先计算再加1，必须在右侧出现第二个a时。才会在第二个a上体现加1的效果）

### 运算符
+ 算术运算符：+ - * / %（取余） =（赋值） **(次方，前为底数，后为指数)
+ 一元运算符：++ --，一个操作数
+ 二元运算符：两个操作数以上
+ 三元运算符：三元表达式，表达式？true的结果：false的结果
+ 复合运算符：+=（a=a+5可写成a+=5） -= *= /=
+ 关系运算符：》 《 ==（值相等） ===（全等，数值和数据类型都相等） ！=（值不等于） ！==（数值和数据类型全不等），所得结果为true或false
+ 逻辑运算符：&&（且） ||（或），两侧条件的真假，结果为布尔；！（非），将布尔的结果取反

### 流程控制语句
+ 顺序结构语句：默认由上至下执行
+ 分支结构语句：根据条件的真假决定是否执行某段代码（注意：等于要用==）
    - 单项判断：if（条件）{操作}，小括号中的条件为true时，执行大括号中的操作，false时不执行
    - 双向判断：if（条件）{操作1}else{操作2}，当条件为false，执行else后面大括号中的操作
    - 多向判断：if（条件）{操作1}else if（条件）{操作2}else{操作3}，叠加多重条件
    - switch-case判断：switch（要比较的值）{case 预设值1：操作1；break；case 预设值2：操作2；break；...default：操作n；break；}
        * 根据要比较的值是否等于预设值判断，break为一次等于后结束，default类似于else，代表都不符合时的操作
        * 默认用法是判断是否相等，如需判断是否符合某个区间，可将要比较的值设为true，则可在预设值处用 变量》=预设值 ,来设置一个区间条件
+ 循环结构语句：重复地执行某段代码
    - for循环：for(var i=0;i《100;i++){操作}
    - while循环：var i=1；while(i《=10){document.write(i);i++;}
        * 由于对循环数的定义在循环外，适用于循环数初始值未知的场景
    - do-while循环：var i=1；do{document.write(i);i++;}while(i《1)
        * 先执行，再判断是否循环，因此至少会执行一次

### 函数prompt（‘字符串’）：在浏览器中弹出一个带输入框的对话框，引号内字符串将在对话框中显示，可返回输入值
+ 函数是有返回值的，可以通过赋值将返回值赋予某个变量

### 在网页中输出：document.write（输出内容）
+ 如果要在JS中使用html标签，需要像输出字符串一样用引号包裹

# 2020/8/13（今天有事，明日补上。今日完成：继续学习昨日循环语句）
### js语句和html标签穿插，产生效果
+ 写在script标签内的html标签，要以字符串形式，用document.write（）输出

### 关系运算符的运算优先级高于逻辑运算符，！可以看成一元运算符，（）优先级最高

# 2020/8/14（今日主要针对一些基本的算法和函数的使用，做了一些练习，知识点不多）
### 当循环中出现break，立刻结束当前最近的循环体

### 当循环中出现continue，结束“当次”循环，即本次循环剩下的操作不执行

### 数组：一组有序数据的集合
+ 创建数组的第一种方式：字面量，如var arr01=[1,2,3],此方式用得最多
    - 数组可通过 数组名.length 获取数组的长度
    - 可通过 数组名[第几个] 访问数组各个元素，从0开始
+ 创建数组的第二种方式：new Array，如var arr02=new Array（1,2,3）
+ 第三种，如果new Array（）的括号中只有一个数值，会直接设置成数组长度，元素都为空
+ 遍历数组，for(i=0;i《arr01.length;i++)，无论数组多长都能实现访问
+ 动态添加数组元素：利用数组长度始终比数组最大序号大1的特点，进行赋值

### 函数：将一段代码进行封装，可以进行重复使用，避免代码冗余
+ 定义形式：function 函数名(){函数内容}
+ 调用形式：函数名（）；
+ 小括号中可放置一个参数，代表输入，即可根据输入内容，进行函数内容中的计算
+ 当小括号中为空时，不需输入也可执行函数
+ 当有多个输入值时，用逗号隔开
+ 函数定义中的参数叫形式参数，函数调用中的参数叫实际参数，两者个数要一一对应
+ 定义和调用的先后顺序可以调换

### 函数的返回值
+ 自定义函数默认的返回值是underfined
+ 可以用 return 返回值；自定义函数的返回值，但必须放在函数最后，因为return将强制结束函数
+ 注意，函数的输出要么要有返回值，要么就要用打印弹框等，总之不要忘了输出，不然就undefined

### 面向对象与面向过程（我觉得讲得很模糊，以下为我现在的理解，待更新）
+ 面向过程，完整描述程序的过程
    - 由于不需要调用对象（少了对象名称的判断、过程代码的调用），理论上响应应该更快，资源占用更少
+ 面向对象，将具有规律的过程，归纳成对象，用对象代替复杂的过程
    - 因为调用节省了重复代码的书写，提升了开发效率；因为定义位置集成，便于维护
+ 基于对象：这里就理解不了了，应该还需要后面的js知识——???待补充

### 函数的其他定义方式
+ 有名函数
    - 定义函数名的方式：function 函数名（）{}，会将函数整个提升到作用域顶部
    - 函数表达式的方式：var 变量=function（）{}，调用方法同上
        * 这种定义方式，只能提升声明，不能提升赋值，因此在定义之前不能作为函数调用

# 2020.8.15（今日完成1.作用域及作用域链；2.对象及原型，原型这块还是不大懂，后面再继续加深理解）
### 匿名函数：没有名字的函数，不能直接定义使用
+ 使用方式：
    - 作为函数表达式
    - 作为参数传递
    - 作为事件处理函数
    - 作为自调用函数：（function(){})(),当次定义即调用，只能用一次
    - 作为返回值

### 对象既有属性，也有方法，方法即是一段函数，或者若干个动作

### new Object方式创建对象
+ var 对象名=new Object();对象名.属性名；
    - 通过以上方式，可以定义对象及多个属性名（属性名可以是表达式函数，如对象名.属性名=function（）{}）

### 工厂方式创建对象
+ 用函数包裹对象，实现对象的输入，如function creatPerson(name,age){var person=new Object();person.name=name;}

### 构造函数方式创建对象
+ 直接抛弃Object，表述为一个函数
+ function person(name,age){this.name=name;this.age=age;}var dxy=new person('龙傲天',23);
    - 在调用时，需要用new在内存中开辟一个新的空间
    - this指代的是当前的实例对象
    - 可以将person理解为一个函数，但是通过new之后，与输入值结合，生成了一个独立的对象
+ 不需要return

### 作用域：变量的访问区域，JS中访问的区域分为两块
+ 全局作用域，在script标签中的就是全局作用域，全局作用域下的对象都是全局对象
+ 全局对象：浏览器顶级对象Window，所有对象都是window下的属性或方法，但这些对象的属性或方法则不是
+ 全局变量
    - 带var定义变量的方式，会将声明提升到作用域顶端，但赋值不会
    - 不带var定义变量的方式，必须是声明加赋值，如a=1； ，声明不会提升，会污染数据——???待补充
+ 函数作用域：函数中var定义的变量无法在外部作用域中访问，是局部私有变量
    - 函数中不带var，就不是定义变量，而是访问外部的变量，会影响全局变量
    - 如果函数（变量）中已经定义的变量，就相当于在函数内var定义了变量
	
### js预解析：js会优先将用var声明的变量提前解析，将声明提升

### 函数也是一种数据类型

### 作用域链：当函数体中访问变量时，优先级：自身私有变量》上层作用域》上上层作用域...

### 构造函数&实例对象&原型对象三者间的关系
+ 构造函数通过赋值，实例化对象
+ 实例对象的属性隐式原型（__proto__），指向原型对象，
+ 原型对象的constructor（构造器），指向构造函数
+ 构造函数中的prototype指向原型对象

### console.dir：可展开显示构造函数

### 实例对象 instanceof 构造函数，可用于判断某一实例是否属于某一类型

### 原型对象作用之一：是一个公共存储空间，可以把公共的属性和方法存储在原型对象中，当创建实例对象时，可以直接访问，实现资源共享
+ 可以直接添加原型对象的方法或属性，使用函数名.prototype.方法名（或属性名）定义

### 原型链：如果实例对象调用某个属性或方法，先从自己的构造函数寻找，如果没有则去构造函数中的原型对象寻找，如果还没有则去上一层构造函数中的原型对象中寻找，以此类推，直到找到Object原型对象（类似于Window）中，还没有则报错，这个过程就是原型链

### 值类型和引用类型的存储方式
+ 简单数据类型：
    - 值类型：number string boolean，b=a，修改b不会影响到a，因为a和b的值存储在内存中的两个位置
    - 空类型：underfined null
+ 复杂数据类型：
    - 引用类型：object，b=a，修改b会影响到a，因为此赋值过程只是将a的地址赋予b，一旦修改b，将会使得a所引用地址的内容改变

### js垃圾回收机制：浏览器会将长时间不再被指向的对象自动清理掉
+ 如果需要取消一个变量的指向，又不想指向其他对象，可以=null

### 通常对象名首字母要大写，函数名首字母小写

### this的指向：在构造函数中，this指向当前实例对象；在普通函数中，this指向的是window

### 另一种访问对象属性和方法的方式：通过p["name"]，可以访问对象p中的name属性，类似于p.name

### 对象与数组
+ 对象：一组无序数据的集合(用语义化属性放置值，调用的时候较方便)
+ 数组：一组有序数据的集合

### 第三种创建对象的方式：字面量
+ var jay={name:'周杰伦',age:41,gender:true};

# 2020/8/16（今日完成1.json、math、date对象；2.字符串常用方法；3.数组常用方法）
### json对象：是一种网络传输数据的格式,用在前后台交互
+ 在传输数据时不能直接传对象，要将对象转换成字符串，即在大括号外加引号
+ 可用JSON.stringify(对象名)将对象转换成字符串
+ 可用JSON.parse（字符串化的对象名）将字符串化的对象转换成对象

### 遍历对象的属性名与属性值
+ for(var i in json01){console.log(i+':'+json01[i]);}
    - 注意，打印i时打印的是属性名，json01[i]才是属性值，并且不能写成json01.i，否则会变成为json添加一个i属性
+ 若只是要访问其中一个属性，可以使用json01["其中某个属性名"]的方式

### call和apply函数：可以改变this的指向
+ 通过对 父级对象（或属性、方法）.call（新的指向）的方式改变父级对象下this的指向，apply可替代call
+ 当父级对象本身有实参时，需要用父级对象.call（新的指向，实参1，实参2）来改变
+ 而用apply时，需要用父级对象.apply（新的指向，[实参1，实参2]）来改变
+ 二者的差别体现在对实参的表达形式上

### Math对象
+ Math.PI：圆周率
+ Math.abs（实参）：绝对值
+ Math.ceil（实参）：向上取整
+ Math.floor（实参）：向下取整，和parseInt一样
+ Math.round（实参）：四舍五入为最接近的整数
+ Math.random（）：返回0~1之间的随机数（不包含1）

### arguments对象：输入的实际参数形成的数组（长度由输入决定），是函数的默认对象实例
### Date对象：
+ var time=new Date(),将当前的计算机时间赋予对象time
    - time.getFullYear(),返回年份
    - time.getMonth()，返回月份，注意，是从0开始，因为月份通常表示为英文字符，因此数字实际上是数组的序号
    - time.getDate()，返回一个月中的某一天
    - time.getDay()，返回一周中的某一天，注意，是从0开始(而周日就是0)，原因同月份
    - time.getHours(),返回当前小时
    - time.getMinutes(),返回当前分钟
    - time.getSeconds(),返回当前秒
    - time.getMilliseconds(),返回当前毫秒
    - time.toLocaleString(),把Date对象转换成字符串
    - time.toLocaleDateString(),把Date对象的日期转换成字符串
    - time.toLocaleTimeString(),把Date对象的时间转换成字符串

### Number、String、Boolean三种值类型，在需要调用对应类型的方法时，会临时创建一个对象以调用方法，结束之后会自动删除临时对象

### 字符串的不可变性：字符串一旦存储后，就不能再改变，即便重新赋值，也只是重新开辟了一个空间存储新值
+ 字符串也是以数组方式进行存储，因此也可以用访问数组中元素的方式访问字符串中的每一个字符，但不能修改

### 字符串常用方法
+ 字符串名.charAt（9），返回位置为9的字符
+ 字符串名.charCodeAt（5），返回位置为5的字符的Unicode编码
+ 字符串名.concat（'啦啦啦'），在字符串后拼接 啦啦啦
+ 字符串名.indexOf（'下',3),从位置为3开始，从前往后索引并返回 下 的位置
+ 字符串名.lastIndexOf（'下'，8），从位置为8开始，从后往前索引并返回 下 的位置
+ 字符串名.replace（'今天','明天'），将远字符串中的今天替换为明天
+ 字符串名.slice（2，5），从位置为2开始，返回5之前的字符（不包括5）
    - 字符串名.substring（2,5）功能同上
+ 字符串名.substr（2,3），从位置为2开始，返回3个字符
+ 字符串名.split（要切割字符），将原字符串根据要切割的字符切割成几段，放在一个数组中
+ 字符串名.toLocaleLowerCase(),转小写
+ 字符串名.toLocaleUpperCase（），转大写
+ 字符串名.trim（），去掉字符串前后的空格
    - 可用在处理输入信息中前后无用的空格

### 数组常用方法
+ 数组名.pop（），从数组尾部弹出一个元素，并返回弹出的元素（即删除）
+ 数组名.push（6），在数组尾部加入一个元素6,并返回数组长度
+ 数组名.shift()，从数组头部弹出一个元素，并返回弹出的元素
+ 数组名.unshift(9)，从数组头部加入一个元素9，并返回数组长度
+ 数组名.concat（数组），在原数组后拼接一个数组，并返回新数组
    - 不会影响原来的数组
+ 数组名.join（连接符号），将数组用连接符号连成字符串
    - 若未输入连接符号，默认用逗号
    - 不会影响原来的数组
+ 数组名.slice（2），从位置为2开始，截取后面的数组
    - 若数组名.slice（2，4），从位置为2开始，截取到4之前的数组（不含4），并返回
    - 不会影响原来的数组
+ 数组名.splice（2）,从位置为2开始，删除后面的数组，并返回被删除的数组
    - 会影响原来的数组
    - 若数组名.splice（2，1），从位置为2开始，删除1个元素，并返回被删除的数组，也会影响原数组
    - 若数组名.splice（2,1，'haha'),则删除完成后，在原来位置2出插入字符串haha，返回的还是删除的数组，也会影响原数组
    - 若数组名.splice（2,0,666），则直接在2的位置插入666，原来2的位置及以后依次延后1位
+ 数组名.reverse()，逆序，并返回逆序后的数组，影响原数组
+ 数组名.sort（），对数组根据首字母排序，数字排在字母前，按照第一位数排序，返回排序后数组，影响原数组
    - 如果要按其他标准进行比较，就需要在括号中提供比较函数如 数组名.sort（fn）；function fn（a，b）{标准}，如果返回值为-1（小于0的值即可），则a排在b前面，如果两个排序不分先后则返回0，如返回值为1（大于0的值即可），则b排在a的前面

# 2020/8/17（关于DOM这块，视频质量太差了，这块只能后面再看书自学.今日完成flex伸缩盒布局）
### 规范制定者
+ ECMAscript——ECMA
	- ECMA-262：javascript规范
	- ECMA-404：json规范
+ DOM——W3C
	- 用JS对HTML进行增删改查（CRUD）操作
	- 用JS进行样式控制

### DOM：文档对象模型
+ 它是一种跨平台、独立于编程语言的API
+ 它把HTML、XML文档当作一个树结构，每个节点视为一个对象，这些对象可以被编程语言操作，进而改变文档的结构，映射到文档的显示
+ 简单来说，DOM就是为了方便编程语言对HTML等文档进行操作
+ 对象层级关系形成的树就叫 DOM树

### 节点
+ DOM把HTML文档中的每个成分都定义成一个节点
	- 整篇文章是一个文档节点，是根节点，
	- 每个HTML标签是一个元素节点
	- 包含在HTML标签中的文本（内容）是文本节点
	- HTML标签的每一个属性是一个属性节点
	- 注释属于注释节点——？？？待补充

### API：应用程序编程接口

### div垂直水平居中
+ position：absolute ;
+ left=0;top=0;right=0;bottom=0;
+ margin:auto;

### 获取元素
+ 通过id获取元素
	- var 元素名=document.getElementById('id名')
+ 通过class获取元素列表
	- var 元素列表名=document.getElementsByClassName('class名')
+ 通过标签名获取元素列表
	- var 元素列表名=document.getElementsByTagName('标签名')
+ 通过class、标签名获取的元素列表，是伪数组

### 伪数组VS真数组
+ 共同点：都有length属性，属性名都以数字表示
+ 不同点：伪数组不能使用数组的api（属性、方法）

### 数组也是对象

### 数组的api
+ 数组名.forEach（回调函数），对数组中的每个元素执行回调函数
	- 回调函数：只需要定义，由浏览器调用执行

### 将伪数组转化为真数组
+ Array.prototype.slice.call(伪数组名)，此方法的返回值为对应的真数组

### 子元素节点
+ 通过id获取元素后，可通过元素名.childNodes获取子节点列表（不剔除文本节点）
+ 通过id获取元素后，可通过元素名.children获取子元素节点列表（剔除文本节点）
+ 只有元素节点才可以有子节点
+ 可以用元素名.childNodes[0]（或.children[0]）的方式，访问子节点列表中的某一个节点
+ 通过id获取元素后，可通过元素名.firstChild获取其第一个子节点
+ 通过id获取元素后，可通过元素名.lastChild获取其最后一个子节点

### 父元素节点
+ 通过id获取元素后，可通过元素名.parentNode获取父元素节点

### 兄弟节点
+ 同一父元素下的其他子节点 
+ 通过id获取元素后，可通过元素名.previousSibling获取前一个兄弟节点
+ 通过id获取元素后，可通过元素名.nextSibling获取后一个兄弟节点

### 操作节点——？？？待补充

### H5课程阶段
+ flex布局
+ h5新增的标签
+ 响应式布局
+ less CSS预处理器
+ canvas画布
+ 自定义滚动条
+ 自定义视频播放器

### 有个看上去还不错的个人学习网站：learn.fuming.site

### 页面布局方式
+ 表格布局
+ 浮动布局
+ 定位布局
+ flex布局（伸缩盒布局）

### flex布局
+ 基本术语
	- 伸缩容器：一个元素设置display:flex或者display：inline-flex就变成了伸缩容器
	- 伸缩项目：伸缩容器的子元素就是伸缩项目，所有伸缩项目是BFC（块格式化上下文）
	- 主轴：伸缩项目排列方向的轴
	- 侧轴：与主轴垂直的轴

### 伸缩容器属性
+ 属性：主轴方向：'flex-direction：',以下为四种排布方向
	- row（默认值）：主轴为水平方向，起点在左端
	- row-reverse：主轴为水平方向，起点在右端
	- column：主轴为垂直方向，起点在上沿
	- column-reverse：主轴为垂直方向，起点在下沿
+ 属性：换行：'flex-wrap：'，以下为3种换行方式
	- nowrap（默认值）：伸缩容器为单行。该情况下伸缩项目可能会溢出容器
	- wrap：伸缩容器为多行。该情况下伸缩项目溢出的部分会被放置到新行，伸缩项目会发生断行
	- wrap-reverse：反转 wrap 排列（以行为单位反转）
+ 复合属性：主轴方向复合换行：'flex-flow：'，主轴方向和换行方式间用空格隔开
+ 属性：伸缩项目在主轴方向上对齐：'justify-content:',以下为六种对齐方式
	- flex-start（默认值）：左对齐
	- flex-end：右对齐
	- center：居中
	- space-between：两端对齐，项目之间的间隔都相等（常用）
	- space-around：每个伸缩项目两侧的间隔相等。所以，伸缩项目之间的间隔比伸缩项目与边框的间隔大一倍
	- space-evenly: 伸缩项目之间的间隔以及缩项目与伸缩容器边框的间隔相等 （新增属性值，兼容性稍差）
+ 属性：伸缩项目在侧轴方向上对齐：'align-items:':以下为五种对齐方式
	- flex-start：侧轴的起点对齐
	- flex-end：侧轴的终点对齐
	- center：侧轴的中点对齐
	- baseline: 伸缩项目的第一行文字的基线对齐(如果没字就是项目下边沿)
	- stretch（默认值）：如果伸缩项目未设置高度或设为auto，将占满整个容器的高度
+ 属性：主轴方向上有多行时，侧轴方向对齐:'align-content',以下为六种对齐方式
	- flex-start：与侧轴的起点对齐
	- flex-end：与侧轴的终点对齐
	- center：与侧轴的中点对齐
	- space-between：与侧轴两端对齐，轴线之间的间隔平均分布
	- space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍
	- stretch（默认值）：轴线占满整个侧轴
	- space-evenly: 轴线的间隔以及轴线与伸缩容器边框的间隔相等（新增属性值，兼容性稍差）

### flex实现水平居中方式 1
+ 在父元素有宽度、高度的前提下
+ 对父元素设置display：flex
+ 对父元素使用 主轴方向居中+侧轴方向居中

### flex实现水平居中方式 2
+ 在父元素有宽度、高度的前提下
+ 对父元素设置display：flex
+ 对子元素设置margin：auto

### 伸缩项目属性
+ 属性：伸缩项目的放大比例：'flex-grow：'，默认0为不放大，根据各元素数字，占所有元素数字之和的比例，分配多余空间
	- 只取决于剩余空间和flex-grow数字
+ 属性：伸缩项目的缩小比例：'flex-shrink'，默认为1，如果空间不足，将按各元素权重各自缩小，缩小空间=总溢出空间*（元素大小*元素数字/各元素加权总和），各元素加权总和为每个元素大小和元素数字相乘后的和
	- 取决于溢出空间、各元素大小和flex-shrink数字
+ 属性：在分配多余空间之前，伸缩项目在主轴方向上的长度：'flex-basis：'，默认为auto即原始尺寸,如果主轴方向是水平的，则代替width，垂直则代替height
	- 决定剩余或溢出空间
+ 复合属性：grow、shrink和basis三个属性的复合：'flex：',以下为几种
	- 如果缩写为 flex: 1 , 则其计算值为 1 1 0（本身宽度变为0，伸缩等分）
	- 如果缩写 flex: auto , 则其计算值为 1 1 auto
	- 如果flex: none , 则其计算值为0 0 auto（不伸不缩）
	- 如果flex: 0 1 auto 或者 flex: initial , 其计算值为0 1 auto，即 flex的默认值（不伸只缩）

### 伸缩项目排序
+ 属性：伸缩项目排列顺序，'order：'，默认为0，数值越大，排列越靠后

### 伸缩项目侧轴单独对齐
+ 属性：单个伸缩项目侧轴对齐方式：'align-self:'，可覆盖父元素的align-items 属性
	- auto(默认值): 表示继承父元素的 align-items 属性
	- flex-start：侧轴的起点对齐
	- flex-end：侧轴的终点对齐
	- center：侧轴的中点对齐
	- baseline: 伸缩项目的第一行文字的基线对齐
	- stretch：如果伸缩项目未设置高度或设为auto，将占满整个容器的高度。

# 2020/8/18(今天做了两个flex布局网页，又花了一天的时间改来改去，算是把讲的新版flex这部分给吃透了吧哈哈哈[不要脸],今天进度太慢了，明天加速)
### flex旧版语法
+ 私有前缀：
	- -webkit-  chrome内核
	- -moz-  火狐内核
+ 伸缩容器
	- 设置伸缩容器：box/inline-box
	- 设置主轴水平或垂直：box-orient
	- 设置主轴方向上的排序：box-direction
	- 主轴对齐：box-pack
	- 侧轴对齐：box-align
+ 伸缩项目
	- 伸缩项目伸缩：box-flex
	- 伸缩项目排序：box-ordinal-group

### flex过渡版语法（为IE10量身定制）
+ 前缀：-ms-
+ 伸缩容器
	- 设置伸缩容器：flexbox/inline-flexbox
	- 主轴方向：flex-direction
	- 换行：flex-wrap
	- 主轴方向复合换行：flex-flow
	- 主轴对齐：flex-pack
	- 侧轴对齐：flex-align
	- 多行侧轴对齐：flex-line-pack
+ 伸缩项目
	- 伸缩项目伸缩：flex
	- 伸缩项目排序：flex-order

### 后期可使用前端工程化工具对代码进行兼容化处理

### background-size:cover,将背景图自动拉伸至覆盖元素

### 使用 lorem数字+Tab键，可生成'数字'个英文单词